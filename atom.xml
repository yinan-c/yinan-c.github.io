<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>1nan</title>
  <link ref="self" href=""/>
  <link ref="alternate" href="https://yinan.me/"/>
  <updated></updated>
  <author>
    <name>Yinan</name>
  </author>
  <id>ba15f2bcfa5336d8d2f005c8f0aa7951c3b52e50</id>

  
  <entry>
    <title>Hello World</title>
    <link ref="alternate" href="https://yinan.me/hello-world.html" />
    <id>hello-world</id>
    <published>2023-06-18 18:59:53+01:00</published>
    <updated>2024-02-01 22:51:50+00:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;h2&gt;我是谁?&lt;/h2&gt;
&lt;p&gt;我叫Yinan，目前在英国读博，物理专业。本科在中科大，也是学的物理。&lt;/p&gt;
&lt;h2&gt;为什么写博客？&lt;/h2&gt;
&lt;p&gt;回想过去的25年，虽然有记录，写笔记的爱好，但是我还没有正经得把自己的所见所思整理，更没有发布。开始读博以后，有意识的把工作记录和日常见闻记录成文档，碎碎念积少成多，也就成为我在这个世界上来过的一点点证明。&lt;/p&gt;
&lt;p&gt;博客作为一个自己的 digital 小岛，我认为非常适合将这些见闻想法汇集。平时阅读很多文章，浏览很多新闻信息，但是大多很快就忘了，它们只是作为信息从我脑中漂过，而不是作为知识想法被我内化。组织语言记录是对这些繁杂信息的整理消化，“再创作”，也是一次自我反思。从这个意义上看，写博客或许可以帮助我学习知识，内化想法，同时可以提升表达想法的能力。&lt;/p&gt;
&lt;p&gt;我个人非常欣赏 Blog 这种“链接孤岛“的想法，同时也非常认同 open web 的愿景，觉得有价值的信息是应该被分享的，至少值得被记录下来。但是我不喜欢中心化的平台，更不用说 under sensorship 的那些，不喜欢被算法推荐的信息来源，我喜欢把数据自托管，所谓的 self-hosted。&lt;/p&gt;
&lt;p&gt;另外还有一个原因，阅读确实会让人有表达的冲动。我从小就不擅长写文章，但我在初中时仍是写了几篇中短篇小说，高中时候也会在月考作文里写写短篇，偶尔还能拿高分，就是因为当时看了很多各式各样的小说，当时的我很有表达，模仿的欲望。而现在写文章能力已经大大退步了，所以写博客权当给自己练练手，希望我能坚持。&lt;/p&gt;
&lt;h2&gt;我会写些什么&lt;/h2&gt;
&lt;p&gt;我平时喜欢折腾软件，写写脚本（因为平时科研工作有太多重复作业了），喜欢打游戏，每天刷刷 RSS，听听播客，听音乐看剧。在日常冲浪中，任何我觉得有意思，有分享意义的东西，都可能会发布在这里。又也许会把之前的一些想法笔记整理出来，发在这里。&lt;/p&gt;
&lt;h2&gt;博客用了什么&lt;/h2&gt;
&lt;p&gt;本博客的文章用 Markdown 编写。
采用了开源方案 &lt;a href=&#34;https://github.com/ahui2016/pyboke&#34;&gt;PyBoke&lt;/a&gt; 生成静态网站，自己在此基础上加了点&lt;a href=&#34;https://github.com/yinan-c/pyboke/&#34;&gt;其他功能&lt;/a&gt;，例如首页显示摘要，文章底部翻页，full text RSS 格式。使用的是 &lt;a href=&#34;https://newcss.net/&#34;&gt;newcss 主题&lt;/a&gt;，再通过 &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt; 发布。&lt;/p&gt;
&lt;p&gt;本博客所有源 markdown 文件，以及模板开源，托管在 &lt;a href=&#34;https://github.com/yinan-c/blog&#34;&gt;GitHub&lt;/a&gt; 上。&lt;/p&gt;
&lt;h2&gt;版权&lt;/h2&gt;
&lt;p&gt;本博客所有文章采用 &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/&#34;&gt;CC BY 4.0&lt;/a&gt; 协议。您可以自由地：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;共享&lt;/strong&gt; - 在任何媒介以任何形式复制、发行本作品 在任何用途下，甚至商业目的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;演绎&lt;/strong&gt; - 修改、转换或以本作品为基础进行创作 在任何用途下，甚至商业目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只要你遵守许可协议条款，许可人就无法收回你的这些权利。&lt;/p&gt;
&lt;p&gt;惟须遵守下列条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;署名&lt;/strong&gt; - 您必须给出 适当的署名 ，提供指向本许可协议的链接，同时 标明是否（对原始作品）作了修改 。您可以用任何合理的方式来署名，但是不得以任何方式暗示许可人为您或您的使用背书。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没有附加限制&lt;/strong&gt; - 您不得适用法律术语或者 技术措施 从而限制其他人做许可协议允许的事情。&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  
  <entry>
    <title>About</title>
    <link ref="alternate" href="https://yinan.me/about.html" />
    <id>about</id>
    <published>2023-06-19 17:35:38+01:00</published>
    <updated>2024-02-01 22:49:46+00:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;p&gt;Hi, I am Yinan, a PhD student in Physics.&lt;/p&gt;
&lt;p&gt;Since I started my PhD, I have been reading and learning a lot, by writing down tons of notes and worklogs. Most of my notes are Markdown files stored in an app called &lt;a href=&#34;https://obsidian.md/&#34;&gt;Obsidian&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Since almost all of my notes are going digital now, it is not a bad idea to put them online. Also, I have been writing short articles in Chinese since very young, but hadn&#39;t had the chance to collect and share them with others. I have been thinking about starting a blog for a long time. &lt;/p&gt;
&lt;p&gt;Now, I finally decided to start one, thanks to a great tool &lt;a href=&#34;https://github.com/ahui2016/pyboke&#34;&gt;PyBoke&lt;/a&gt;, which makes it very easy to create a blog using Markdown files. I know other tools like WordPress and Hugo that can do the same thing, but I like the simplicity of PyBoke. &lt;/p&gt;
&lt;h2&gt;About this blog&lt;/h2&gt;
&lt;p&gt;This blog is created by a modified version of &lt;a href=&#34;https://github.com/yinan-c/pyboke&#34;&gt;PyBoke&lt;/a&gt;, where I added features like full text RSS, navigation buttons, and abstracts on the homepage.
The original version of PyBoke is created by &lt;a href=&#34;https://github.com/ahui2016&#34;&gt;ahui2016&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This blog is fully open source. All the articles in Markdown format, together with the templates I use on this website can also be found in the &lt;a href=&#34;https://github.com/yinan-c/blog&#34;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I use the theme &lt;a href=&#34;https://newcss.net/&#34;&gt;newcss&lt;/a&gt;, and publish the blog on &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;What will I write here?&lt;/h2&gt;
&lt;p&gt;I am interested in many things, including but not limited to: RSS, macOS softwares, Python ... As I browse the internet (mostly via RSS), interesting things will pop up and I am happy to share online here.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Twitter logo icons created by &lt;a href=&#34;https://www.flaticon.com/free-icon/twitter_3670151&#34;&gt;Md Tanvirul Haque - Flaticon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Email icon from &lt;a href=&#34;https://www.freepnglogos.com/images/email-13765.html&#34;&gt;freepnglogos.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;License&lt;/h1&gt;
&lt;p&gt;The articles I write are licensed under &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/&#34;&gt;CC BY 4.0&lt;/a&gt;. You are free to: 
- &lt;strong&gt;Share&lt;/strong&gt; — copy and redistribute the material in any medium or format
- &lt;strong&gt;Adapt&lt;/strong&gt; — remix, transform, and build upon the material
for any purpose, even commercially.&lt;/p&gt;
&lt;p&gt;The licensor cannot revoke these freedoms as long as you follow the license terms.&lt;/p&gt;
&lt;p&gt;Under the following terms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Attribution&lt;/strong&gt; — You must give appropriate credit , provide a link to the license, and indicate if changes were made . You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No additional restrictions&lt;/strong&gt; — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  
  <entry>
    <title>How to let your shell to remember your commands</title>
    <link ref="alternate" href="https://yinan.me/shell-auto-suggestions.html" />
    <id>shell-auto-suggestions</id>
    <published>2024-02-01 17:09:21+00:00</published>
    <updated>2024-02-01 22:26:17+00:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;p&gt;Whenever you got a new machine, there&#39;s always endless configurations porting, codes compilations and packages installations. It is crutial step to make the new machine meets your habits.&lt;/p&gt;
&lt;p&gt;Recently, I got access to a new supercomputer for a limited amount of time, I started using it without much configuration. Soon I found myself missing the convenience of auto-suggestion for commands, which I got used to in prevously machines I&#39;ve wored on.&lt;/p&gt;
&lt;p&gt;Auto-suggestion in your shell is basically a plugin/extension that remembers your commands history and provide suggestions when you type in the first few letters of a command. When you find yourself frequently using the same commands (such as &lt;code&gt;ssh&lt;/code&gt; to a specific server), it could be really useful.&lt;/p&gt;
&lt;p&gt;This is how the suggestions will look like (I&#39;m using zsh-autosuggestions here):&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/zsh.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So this article is mainly to give recommendations for both zsh and bash users on how to configure the shell to remember your commands.&lt;/p&gt;
&lt;h2&gt;1. zsh-autosuggestions for zsh&lt;/h2&gt;
&lt;p&gt;On my mac, zsh is the default shell, the plugin &lt;code&gt;zsh-autosuggestions&lt;/code&gt; is what I want to recommend here. It suggests commands when you type in a zsh shell, and you can simply press the right arrow key to accept the suggestion.&lt;/p&gt;
&lt;p&gt;To install it, you can follow the instructions on their &lt;a href=&#34;https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md&#34;&gt;github repo&lt;/a&gt;. You can use Antigen, Oh My Zsh, Homebrew or manually install it.&lt;/p&gt;
&lt;p&gt;I use oh-my-zsh for managing my zsh configurations. Actually I&#39;m using a rather minimal configuration of oh-my-zsh, which consists only 2 plugins. These are the lines to configure oh-my-zsh in my &lt;code&gt;~/.zshrc&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
export ZSH=&#34;$HOME/.oh-my-zsh&#34;
ZSH_THEME=&#34;alanpeabody&#34;
plugins=(git zsh-syntax-highlighting zsh-autosuggestions)
source $ZSH/oh-my-zsh.sh&lt;/code&gt;
As you can see, to install &lt;code&gt;zsh-autosuggestions&lt;/code&gt; you just need to add it to the &lt;code&gt;plugins&lt;/code&gt; list, separated by a space, tab, or newline.&lt;/p&gt;
&lt;p&gt;There are definitely more to explore in oh-my-zsh, but I&#39;m not going to talk about them in detail here. If you&#39;re interested in more configurations, you can always check out the &lt;a href=&#34;https://ohmyz.sh/&#34;&gt;official website&lt;/a&gt; or their &lt;a href=&#34;https://github.com/ohmyzsh/ohmyzsh&#34;&gt;github repo&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(PS. I also recommend &lt;a href=&#34;https://github.com/sindresorhus/pure&#34;&gt;pure&lt;/a&gt; as a beautiful and minimal ZSH prompt theme, and it is developed and maintained by my favorite open source and mac apps developer Sindre Sorhus.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2. ble.sh for bash&lt;/h2&gt;
&lt;p&gt;For some linux machines, bash is default shell. If you are using bash, I would recommend &lt;a href=&#34;https://github.com/akinomyoga/ble.sh&#34;&gt;ble.sh&lt;/a&gt;, which stands for Bash Line Editor.&lt;/p&gt;
&lt;p&gt;I was looking for a way to let my bash shell to remember my commands, and I found there is a &lt;a href=&#34;https://github.com/ohmybash/oh-my-bash&#34;&gt;oh-my-bash&lt;/a&gt; repo, which is the counterpart of oh-my-zsh, for managing your bash configuration. However, I couldn&#39;t find a easy-to-use auto-suggestion plugin that can be installed via oh-my-bash.&lt;/p&gt;
&lt;p&gt;Then I found &lt;a href=&#34;https://github.com/akinomyoga/ble.sh&#34;&gt;ble.sh&lt;/a&gt;, and you can even try it first without installation.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone --recursive --depth 1 --shallow-submodules https://github.com/akinomyoga/ble.sh.git
make -C ble.sh
source ble.sh/out/ble.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Then try typing in a few commands, you&#39;ll find it achieves the same functionality as &lt;code&gt;zsh-autosuggestions&lt;/code&gt;, it even gives suggestions on commands that you never used before.&lt;/p&gt;
&lt;p&gt;If you like it, you can quickly install it via running the following command:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone --recursive --depth 1 --shallow-submodules https://github.com/akinomyoga/ble.sh.git
make -C ble.sh install PREFIX=~/.local
echo &#39;source ~/.local/share/blesh/ble.sh&#39; &amp;gt;&amp;gt; ~/.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I hope some of you will find this article useful, and I&#39;m also looking forward to hearing your recommendations on other useful plugins or your shell configurations.&lt;/p&gt;</content>
  </entry>
  
  <entry>
    <title>如何让 Shell 记住常用命令</title>
    <link ref="alternate" href="https://yinan.me/shell-auto-suggestions-zh.html" />
    <id>shell-auto-suggestions-zh</id>
    <published>2024-02-01 18:04:18+00:00</published>
    <updated>2024-02-01 22:26:17+00:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;p&gt;每当配置一台新服务器时，迁移配置、编译代码和安装包，都是最一开始要做的事情。
最近，我们组有了一台新的超算，但给的时间有限，于是我几乎没有配置，登录上编译完软件包就开始用了。然而，在我一而再再而三重复输入类似的命令后，我发现自己已然适应，甚至完全离不开命令自动补全带给我的便利了。&lt;/p&gt;
&lt;p&gt;Shell 自动建议是在你输入一条命令的前几个字母时，从命令行历史中给出补全建议。如果你需要经常输入相同或类似的命令时（例如，ssh到特定的服务器），那么这个功能会非常有用，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/zsh.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;因此，本文主要是给 zsh 和 bash 用户推荐 Shell 记住常用历史命令的插件，以及如何安装和配置它们。&lt;/p&gt;
&lt;h2&gt;1. ZSH 用户：zsh-autosuggestions&lt;/h2&gt;
&lt;p&gt;在 Mac 上，zsh 是默认的 shell，我推荐使用 &lt;code&gt;zsh-autosuggestions&lt;/code&gt; 插件。如其名，它会在你输入 zsh 命令时自动给出建议，然后按右箭头键接受建议。&lt;/p&gt;
&lt;p&gt;可以按照其 &lt;a href=&#34;(https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md)&#34;&gt;github repo&lt;/a&gt; 上的说明进行安装，安装方式有 Antigen、Oh My Zsh、Homebrew 或手动安装。&lt;/p&gt;
&lt;p&gt;我使用的是 oh-my-zsh 来管理 zsh 配置，这是我在 &lt;code&gt;~/.zshrc&lt;/code&gt; 中有关 oh-my-zsh 的代码，我目前使用得很简单，只有两个插件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;export ZSH=&#34;$HOME/.oh-my-zsh&#34;
ZSH_THEME=&#34;alanpeabody&#34;
plugins=(git zsh-syntax-highlighting zsh-autosuggestions)
source $ZSH/oh-my-zsh.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看到安装方式十分简单，只需把 &lt;code&gt;zsh-autosuggestions&lt;/code&gt; 加入到 &lt;code&gt;plugins&lt;/code&gt; 列表中，用空格、制表符或换行符分隔不同的插件即可。&lt;/p&gt;
&lt;p&gt;当然，oh-my-zsh 还有很多其他可玩的地方，不管是主题还是插件，这里就不详细介绍了。如果你对更多配置感兴趣，可以查看 &lt;a href=&#34;https://ohmyz.sh/&#34;&gt;官方网站&lt;/a&gt; 或他们的 &lt;a href=&#34;https://github.com/ohmyzsh/ohmyzsh&#34;&gt;github repo&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（PS. 另外我还推荐 &lt;a href=&#34;https://github.com/sindresorhus/pure&#34;&gt;pure&lt;/a&gt; 作为一个漂亮而简洁的 ZSH 提示符主题，它也是我最崇拜的开源和 Mac 应用程序开发者 Sindre Sorhus 开发维护的。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2. BASH 用户：ble.sh&lt;/h2&gt;
&lt;p&gt;对于一些 Linux 机器，bash 是默认的 shell。如果你使用 bash，我推荐 &lt;a href=&#34;https://github.com/akinomyoga/ble.sh&#34;&gt;ble.sh&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我在寻找让 bash 记住常用命令的方法时，发现了 &lt;a href=&#34;https://github.com/ohmybash/oh-my-bash&#34;&gt;oh-my-bash&lt;/a&gt;，和 oh my zsh 对应，它可以用来管理 bash 配置，但我没有找到一个可以通过它轻松安装的 auto suggestions 插件。&lt;/p&gt;
&lt;p&gt;然后我发现了 ble.sh，它甚至提供了试用命令，你可以不用安装的情况下暂时使用它，只需运行以下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone --recursive --depth 1 --shallow-submodules https://github.com/akinomyoga/ble.sh.git
make -C ble.sh
source ble.sh/out/ble.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当你尝试输入一些命令，你会发现它和 &lt;code&gt;zsh-autosuggestions&lt;/code&gt; 的基本功能是一样的，甚至会给出你从未使用过的命令的建议。&lt;/p&gt;
&lt;p&gt;如果你喜欢它，当然也可以通过运行以下命令快速安装：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone --recursive --depth 1 --shallow-submodules https://github.com/akinomyoga/ble.sh.git
make -C ble.sh install PREFIX=~/.local
echo &#39;source ~/.local/share/blesh/ble.sh&#39; &amp;gt;&amp;gt; ~/.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;希望本文对你有用，也期待听到你对其他插件或 shell 配置的建议。&lt;/p&gt;</content>
  </entry>
  
  <entry>
    <title>My App Defaults</title>
    <link ref="alternate" href="https://yinan.me/my-defaults.html" />
    <id>my-defaults</id>
    <published>2023-11-09 21:30:40+00:00</published>
    <updated>2023-11-09 23:01:18+00:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;p&gt;Inspired by &lt;a href=&#34;https://listen.hemisphericviews.com/097&#34;&gt;Hemispheric Views 097 - Duel of the Defaults!&lt;/a&gt; and blog posts by &lt;a href=&#34;https://defaults.rknight.me/&#34;&gt;many&lt;/a&gt;. I would like to write my own defaults too.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;📮 &lt;strong&gt;Mail Server&lt;/strong&gt;: iCloud and Gmail&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📨 &lt;strong&gt;Mail Client&lt;/strong&gt;: iOS: &lt;a href=&#34;https://sparkmailapp.com/&#34;&gt;Spark&lt;/a&gt; and Mail.app and macOS: &lt;a href=&#34;https://canarymail.io/&#34;&gt;Canary Mail&lt;/a&gt; and Mail.app&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📝 &lt;strong&gt;Notes&lt;/strong&gt;: &lt;a href=&#34;https://obsidian.md/&#34;&gt;Obsidian&lt;/a&gt; and &lt;a href=&#34;https://www.devontechnologies.com/apps/devonthink&#34;&gt;DEVONthink&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;✅ &lt;strong&gt;To-Do&lt;/strong&gt;: Previously &lt;a href=&#34;https://culturedcode.com/things/&#34;&gt;Things&lt;/a&gt;, now &lt;a href=&#34;https://www.omnigroup.com/omnifocus/&#34;&gt;OmniFocus&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📷 &lt;strong&gt;iPhone Photo Shooting&lt;/strong&gt;: Camera.app&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🟦 &lt;strong&gt;Photos Management&lt;/strong&gt;: Photos.app&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📆 &lt;strong&gt;Calendar&lt;/strong&gt;: Calendar.app (Personal) and Outlook (Work)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📅 &lt;strong&gt;Calendar Backend&lt;/strong&gt;: iCloud (Personal) and Nexus365 (Work)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📁 &lt;strong&gt;Cloud File Storage&lt;/strong&gt;: iCloud Drive (Personal) and Google Drive (Work)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📖 &lt;strong&gt;RSS&lt;/strong&gt;: Previously &lt;a href=&#34;https://www.reederapp.com/&#34;&gt;Reeder&lt;/a&gt; with &lt;a href=&#34;https://www.freshrss.org/&#34;&gt;FreshRSS&lt;/a&gt;, Now &lt;a href=&#34;https://netnewswire.com/&#34;&gt;NetNewsWire&lt;/a&gt; iCloud account&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🙍🏻‍♂️ &lt;strong&gt;Contacts Management&lt;/strong&gt;: Contacts.app&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🌐 &lt;strong&gt;Browser&lt;/strong&gt;: Safari on iOS, and &lt;a href=&#34;https://arc.net/&#34;&gt;Arc&lt;/a&gt; on my Mac&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;💬 &lt;strong&gt;Chat&lt;/strong&gt;: &lt;a href=&#34;https://wechat.com/&#34;&gt;WeChat&lt;/a&gt;, &lt;a href=&#34;https://telegram.org/&#34;&gt;Telegram&lt;/a&gt;, &lt;a href=&#34;https://slack.com/&#34;&gt;Slack&lt;/a&gt; and &lt;a href=&#34;https://discord.com/&#34;&gt;Discord&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🔖 &lt;strong&gt;Bookmarks&lt;/strong&gt;: &lt;a href=&#34;https://anybox.app/&#34;&gt;Anybox&lt;/a&gt; and &lt;a href=&#34;https://www.devontechnologies.com/apps/devonthink&#34;&gt;DEVONthink&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📑 &lt;strong&gt;Read-it-Later&lt;/strong&gt;: &lt;a href=&#34;https://www.omnigroup.com/omnifocus/&#34;&gt;OmniFocus&lt;/a&gt; and &lt;a href=&#34;https://www.devontechnologies.com/apps/devonthink&#34;&gt;DEVONthink&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📜 &lt;strong&gt;Word Processing&lt;/strong&gt;: Google Docs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📈 &lt;strong&gt;Spreadsheets&lt;/strong&gt;: Google Sheets&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📊 &lt;strong&gt;Presentations&lt;/strong&gt;: Keynote.app, and PDF generated from Markdown using &lt;a href=&#34;https://pandoc.org&#34;&gt;Pandoc&lt;/a&gt; or &lt;a href=&#34;https://latex-project.org&#34;&gt;LaTeX&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🛒 &lt;strong&gt;Shopping List&lt;/strong&gt;: &lt;a href=&#34;https://www.omnigroup.com/omnifocus/&#34;&gt;OmniFocus&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🍴 &lt;strong&gt;Meal Planning (as Recipe Management)&lt;/strong&gt;: N/A, not that I don&#39;t eat/cook, but I don&#39;t have a meal planning system.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;💰 &lt;strong&gt;Budgeting and finance&lt;/strong&gt;: &lt;a href=&#34;https://apps.apple.com/gb/app/cookie-%E8%AE%B0%E8%B4%A6-money-manager/id1559943673&#34;&gt;Cookie&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📰 &lt;strong&gt;News&lt;/strong&gt;: From podcast, RSS feeds and Twitter.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🎵 &lt;strong&gt;Music&lt;/strong&gt;: Apple Music, sometimes on &lt;a href=&#34;https://www.bilibili.com/&#34;&gt;Bilibili&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🎤 &lt;strong&gt;Podcast&lt;/strong&gt;: &lt;a href=&#34;https://apps.apple.com/gb/app/%E5%B0%8F%E5%AE%87%E5%AE%99-%E4%B8%80%E8%B5%B7%E5%90%AC%E6%92%AD%E5%AE%A2/id1488894313&#34;&gt;小宇宙&lt;/a&gt; for Chinese channels and Apple Podcasts for all others. I am also using &lt;a href=&#34;https://podwise.xyz/&#34;&gt;Podwise.xyz&lt;/a&gt; as an AI tool.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🔐 &lt;strong&gt;Password Management&lt;/strong&gt;: &lt;a href=&#34;https://1password.com/&#34;&gt;1Password&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🧑‍💻 &lt;strong&gt;Code Editor&lt;/strong&gt;: &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;Visual Studio Code&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  
  <entry>
    <title>RSS-GPT Configuration</title>
    <link ref="alternate" href="https://yinan.me/rss-gpt-manual-en.html" />
    <id>rss-gpt-manual-en</id>
    <published>2023-09-11 18:14:50+01:00</published>
    <updated>2023-11-07 22:15:43+00:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yinan-c/RSS-GPT&#34;&gt;yinan-c/RSS-GPT&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yinan-c.github.io/rss-gpt.html&#34;&gt;RSS-GPT Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yinan-c.github.io/rss-gpt-manual-zh.html&#34;&gt;中文教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GitHub account&lt;/li&gt;
&lt;li&gt;OpenAI API Key (get it at &lt;a href=&#34;https://platform.openai.com/account/api-keys&#34;&gt;OpenAI website&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1. GitHub Actions deployment&lt;/h2&gt;
&lt;p&gt;The main idea is to use GitHub Actions to run Python scripts periodically, the script calls OpenAI API to generate summaries and append them to original RSS entries, then generate a new xml file, and commit it to the repo. &lt;/p&gt;
&lt;p&gt;All contents in the repo folder are deployed on GitHub Pages, so you can access the xml file via your GitHub Pages URL, and subscribe to it like normal RSS feeds in any RSS reader.&lt;/p&gt;
&lt;p&gt;If you don&#39;t want to deploy on GitHub Pages, you can also subscribe to the raw xml file in the repo (URL starts with &lt;code&gt;https://raw.githubusercontent.com&lt;/code&gt;), e.g. the xml file URL of this repo is &lt;a href=&#34;https://raw.githubusercontent.com/yinan-c/RSS-GPT/main/docs/brett-terpstra.xml&#34;&gt;https://raw.githubusercontent.com/yinan-c/RSS-GPT/main/docs/brett-terpstra.xml&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;1.1 Fork the project&lt;/h3&gt;
&lt;p&gt;Go to the project &lt;a href=&#34;https://github.com/yinan-c/RSS-GPT&#34;&gt;RSS-GPT&lt;/a&gt; and fork it to your own repo. I recommend not to change the repo name, if you do so, you&#39;ll have to modify &lt;code&gt;main.py&lt;/code&gt; in step 3.&lt;/p&gt;
&lt;h3&gt;1.2 Three Repo Secrets&lt;/h3&gt;
&lt;h4&gt;U_NAME&lt;/h4&gt;
&lt;p&gt;The username used for &lt;code&gt;git commit&lt;/code&gt;, &lt;strong&gt;please set to your GitHub username&lt;/strong&gt;.&lt;/p&gt;
&lt;h4&gt;U_EMAIL&lt;/h4&gt;
&lt;p&gt;The email used for &lt;code&gt;git commit&lt;/code&gt;, it&#39;s the email you used to register GitHub, can be found in &lt;a href=&#34;https://github.com/settings/emails&#34;&gt;GitHub Settings page&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;WORK_TOKEN&lt;/h4&gt;
&lt;p&gt;Since the project involves using scripts to operate repo contents, permissions are needed for the script to modify files in the repo. Apply for a new personal access token (classic) in &lt;a href=&#34;https://github.com/settings/tokens/new&#34;&gt;GitHub settings page&lt;/a&gt; and configure the new token as follows:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/token-set.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Note: RSS-GPT or any name you like&lt;/li&gt;
&lt;li&gt;Select scopes: Check all options under &#34;repo&#34; and &#34;workflow&#34; &lt;/li&gt;
&lt;li&gt;Expiration: Choose &#34;No expiration&#34; &lt;/li&gt;
&lt;li&gt;Click &#34;Generate token&#34; at bottom.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/token-copy.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Copy the token after clicking, make sure to copy it on this page, you won&#39;t be able to see the token after leaving this page. If you miss it, you&#39;ll have to generate a new one following the steps above.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;1.3 Set Repository Secrets&lt;/h3&gt;
&lt;p&gt;Go to your forked repo, click &#34;Settings&#34; in top menu bar, then click &#34;Secrets and variables&#34; in left sidebar, choose &#34;Actions&#34;, then click &#34;New repository secret&#34; at top right. &lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/secrets.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Add &lt;code&gt;U_NAME&lt;/code&gt;, &lt;code&gt;U_EMAIL&lt;/code&gt;, &lt;code&gt;WORK_TOKEN&lt;/code&gt;, &lt;code&gt;OPENAI_API_KEY&lt;/code&gt; as secrets to the repo, can only add one at a time:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Name: U_NAME, U_EMAIL, WORK_TOKEN, OPENAI_API_KEY&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Value: Your username, email, the copied GitHub token and OpenAI API Key&lt;/li&gt;
&lt;li&gt;Click &#34;Add secret&#34;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.4 Grant required permissions&lt;/h3&gt;
&lt;p&gt;Enable GitHub Actions access to Pages:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/pages.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Click &#34;Settings&#34; in top menu bar&lt;/li&gt;
&lt;li&gt;Find &#34;Pages&#34; under &#34;Code and automation&#34; in left sidebar and click in&lt;/li&gt;
&lt;li&gt;Set source as deploy from main branch /docs folder.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. Configure RSS sources to merge, filter and summarize&lt;/h2&gt;
&lt;p&gt;Go to the project, open the &#34;config.ini&#34; file, click the pencil icon at top right to edit code and configure your desired sources. Don&#39;t change the first two lines.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[cfg] 
base = &#34;docs/&#34;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Then modify the &lt;strong&gt;target language, number of keywords, and summary length&lt;/strong&gt; in the next 3 lines. The following code is feed-specific configs, format is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[source001]&lt;/code&gt;: Feed ID, starts from 001 and increments, make sure IDs are unique to avoid errors.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name = &#34;brett-terpstra&#34;&lt;/code&gt;: Name of the generated feed, only letters (a-z A-Z), numbers (0-9), (&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;_&lt;/code&gt;,&lt;code&gt;.&lt;/code&gt;,&lt;code&gt;~&lt;/code&gt;) allowed. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;url = &#34;https://brett.trpstra.net/brettterpstra&#34;&lt;/code&gt;: Original RSS feed URL, can contain multiple feeds separated by comma. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_items = &#34;10&#34;&lt;/code&gt;: Number of articles to summarize between refreshes. E.g. 10 means summarizing the latest 10 articles on each refresh. If set to 0 or not set, no articles will be summarized and original entries will be returned.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next are optional filter configs, &lt;strong&gt;note all three configs must be set or not set at the same time, error will occur if only one or two of them are set&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filter_apply = &#34;title&#34;&lt;/code&gt;: Apply filter on &#34;title&#34;, &#34;article&#34; (content) or &#34;link&#34;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter_type = &#34;exclude&#34;&lt;/code&gt;: Filter type: &#34;include&#34;, &#34;exclude&#34;, &#34;regex match&#34; or &#34;regex not match&#34;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter_rule = &#34;TextExpander&#34;&lt;/code&gt;: Filter text or regex.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Click &#34;Commit changes&#34; at bottom to submit edits.&lt;/p&gt;
&lt;h2&gt;3 Modify &lt;code&gt;main.py&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(if you used default repo name in 1.1 and you don&#39;t want to modify prompt, you can skip this step)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open &#34;main.py&#34; file, click the pencil icon to edit code, go to line 290 and modify the &#34;RSS-GPT&#34; in &#34;https://{U_NAME}.github.io/RSS-GPT&#34; to your repo name.&lt;/li&gt;
&lt;li&gt;(Optional) Modify prompt at lines 113-129 based on your needs for better summaries. &lt;/li&gt;
&lt;li&gt;Click &#34;Commit changes&#34; at bottom to submit edits.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4. Configure and test GitHub Actions&lt;/h2&gt;
&lt;p&gt;Go to the project, click &#34;Actions&#34; in top menu bar, click &#34;cron_job&#34; and choose &#34;Run workflow&#34;.&lt;/p&gt;
&lt;p&gt;Green check mark means successful run, red x means failure, usually due to errors in edited ini file or incorrect permissions/tokens. Double check if errors occur.&lt;/p&gt;
&lt;p&gt;If there are no errors, you should see your feeds on the project README page. &lt;/p&gt;
&lt;p&gt;On the left of &lt;code&gt;-&amp;gt;&lt;/code&gt; is original URL, right is converted URL to subscribe like any other RSS feeds.&lt;/p&gt;
&lt;h2&gt;Some extra notes&lt;/h2&gt;
&lt;h3&gt;About feeds refresh frequency&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Default run frequency is every 2 hours, modify &lt;code&gt;.github/workflows/cron_job.yml&lt;/code&gt; line 7 to change, e.g. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;- cron: &#39;0 */2 * * *&#39; # run every 2 hours
   - cron: &#39;0 */1 * * *&#39; # run every 1 hours
   - cron: &#39;0 0 * * *&#39; # run every day at 00:00
   - cron: &#39;*/30 * * * *&#39; # run every 30 minutes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;For more info on cron syntax, see &lt;a href=&#34;https://crontab.guru/&#34;&gt;crontab docs&lt;/a&gt; or &lt;a href=&#34;https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule&#34;&gt;GitHub docs&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;What if I don&#39;t want to use summarization feature?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Well, you can still use this script to filter and merge multiple subscription sources. You just need to not set the OpenAI API Key in 1.3, or not set the &lt;code&gt;max_items&lt;/code&gt; in &lt;code&gt;config.ini&lt;/code&gt;, or set it to 0. By default, this script can also return the original article entries when the AI call fails. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you do want the AI summarization feature and have correctly set &lt;code&gt;config.ini&lt;/code&gt;, but still receive the original entries without summarization or experience infrequent updates, you can check the error information of the OpenAI API or feedparser from the &lt;code&gt;feed_name.log&lt;/code&gt; file in the &lt;code&gt;docs/&lt;/code&gt; subdirectory of the repo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;About AI summary content&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;My prompt is basically asking AI to extract keywords + summarize + auto-formatting. Formatting is not always perfect, and my prompt is not perfectly optmized for everyone. You can modify prompt at lines 113-129 based on your needs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AI summaries are based on the description of each article in the feed. If the RSS itself provides the full text article, the full text will be summarized; if the RSS only provides the article summary, the summary will be based on the summary, and the script does not currently provide the function of crawling the full text of the original article.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;About the usage of OpenAI API&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Regarding the usage of the OpenAI API, in order to minimize costs as much as possible, the following default measures have been adopted for this project:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All unrelevent content (images, frames, HTML tags etc.) are removed before sending to OpenAI API, in order to reduce the token length and cost.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the text length exceeds 16k, &lt;code&gt;gpt-4-1106-preview&lt;/code&gt; will be used, otherwise &lt;code&gt;GPT-3.5 Turbo&lt;/code&gt; is used by default. If you want to use a different model, you can modify the model parameter passed to the &lt;code&gt;gpt_summary&lt;/code&gt; function of lines 227-243 of main.py, e.g. &lt;code&gt;model=&#34;your_model&#34;&lt;/code&gt;. Please refer to the &lt;a href=&#34;https://openai.com/pricing/&#34;&gt;OpenAI API Pricing&lt;/a&gt; for different prices of different OpenAI models.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The script will read the xml files already existing in the docs/ folder. Existing articles will not be summarized again, so OpenAI API will not be repeatedly consumed. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;About repo updates&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I have separated manual edits and workflow auto commits into different branches, so you can see when and what I have edited in the &lt;code&gt;dev&lt;/code&gt; branch to decide whether to pull the latest changes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If OpenAI releases more models in the future, I will choose the most suitable default model and update the code accordingly. If you have a better way to use AI or encounter any issues or spotted any errors, feel free to &lt;a href=&#34;mailto:yinan.email@gmail.com&#34;&gt;email me&lt;/a&gt;. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  
  <entry>
    <title>RSS-GPT 使用指南</title>
    <link ref="alternate" href="https://yinan.me/rss-gpt-manual-zh.html" />
    <id>rss-gpt-manual-zh</id>
    <published>2023-09-11 17:51:18+01:00</published>
    <updated>2023-11-07 22:15:43+00:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;h2&gt;项目地址与功能介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yinan-c/RSS-GPT&#34;&gt;yinan-c/RSS-GPT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yinan-c.github.io/rss-gpt.html&#34;&gt;RSS-GPT介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yinan-c.github.io/rss-gpt-manual-en.html&#34;&gt;English manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;需要准备的东西&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GitHub 账号&lt;/li&gt;
&lt;li&gt;OpenAI API Key （可以在&lt;a href=&#34;https://platform.openai.com/account/api-keys&#34;&gt;这里&lt;/a&gt;建立账号申请）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1 GitHub Actions 部署&lt;/h2&gt;
&lt;p&gt;大致原理是使用 GitHub Actions 定时运行 Python 脚本, 脚本调用 OpenAI API 生成总结附在 RSS 原文之前, 生成一个新的 xml 文件, 并自动 commit 到仓库中 docs/ 文件夹内。&lt;/p&gt;
&lt;p&gt;文件夹内所有内容都将自动部署在 GitHub Pages 上, 这样就可以通过你的 Pages 地址访问到这个 xml 文件, 然后就可以在任何 RSS 阅读器中订阅。&lt;/p&gt;
&lt;p&gt;如果你不想部署在 GitHub Pages, 应该也可以通过直接访问仓库中的 xml 原文件（地址以 &lt;code&gt;https://raw.githubusercontent.com&lt;/code&gt; 开头）来订阅, 比如说我这个仓库的 xml 文件地址是 &lt;a href=&#34;https://raw.githubusercontent.com/yinan-c/RSS-GPT/main/docs/brett-terpstra.xml&#34;&gt;https://raw.githubusercontent.com/yinan-c/RSS-GPT/main/docs/brett-terpstra.xml&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;1.1 Fork项目&lt;/h3&gt;
&lt;p&gt;进入项目 &lt;a href=&#34;https://github.com/yinan-c/RSS-GPT&#34;&gt;RSS-GPT&lt;/a&gt;, 然后 fork 项目到自己的仓库。&lt;/p&gt;
&lt;h3&gt;1.2 记录三个需要的参数&lt;/h3&gt;
&lt;h4&gt;U_NAME&lt;/h4&gt;
&lt;p&gt;就是 &lt;code&gt;git commit&lt;/code&gt; 用的用户名, 一般可以用你的 GitHub 用户名, 你的 GitHub 主页地址的最后一段就是你的用户名, 比如 https://github.com/yinan-c, 用户名就是 yinan-c。&lt;/p&gt;
&lt;h4&gt;U_EMAIL&lt;/h4&gt;
&lt;p&gt;就是 &lt;code&gt;git commit&lt;/code&gt; 用的邮箱, 是你注册 GitHub 时的邮箱, 可以在 &lt;a href=&#34;https://github.com/settings/emails&#34;&gt;GitHub 设置页面&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;WORK_TOKEN&lt;/h4&gt;
&lt;p&gt;因为项目涉及使用脚本操作仓库内容,所以需要给脚本修改仓库内文件的权限,需要申请一个 Repository Secret 令牌。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;点击 GitHub 主页右上角自己的头像, 点 &#34;Settings&#34; 进入设置页面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击左侧菜单栏一列最下方的 “&amp;lt; &amp;gt; Developer settings&#34; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点开左侧菜单栏下方的 “ 🔑 Personal access tokens&#34;, 选择 ”Tokens (classic)“, 点开左上角的 &#34;Generate new token&#34;, 选择第二项 &#34;Generate new token (classic)&#34; 生成一个新的 token。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置新建的token&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/token-set.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Note: RSS-GPT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Select scopes: 勾选前两栏 &#34;repo&#34; 和 &#34;workflow&#34; 内的所有选项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Expiration: 选 &#34;No expiration&#34; (无期限)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击页面最下方的 &#34;Generate token&#34;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/token-copy.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击完后复制token, 注意一定要在此页面复制好, 离开这个页面你就再也看不到token了。错过就只能按照上面的步骤重新生成一个了&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;1.3 设置 Repository Secrets&lt;/h3&gt;
&lt;p&gt;进入你 fork 的 repository, 点击上方菜单栏的 &#34;Settings&#34;, 然后点开左侧菜单栏的 &#34;Secrets and variables&#34;, 选择 &#34;Actions&#34;, 然后点击右上角的 &#34;New repository secret&#34;。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/secrets.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给仓库分别添加 &lt;code&gt;U_NAME&lt;/code&gt;, &lt;code&gt;U_EMAIL&lt;/code&gt;, &lt;code&gt;WORK_TOKEN&lt;/code&gt;, &lt;code&gt;OPENAI_API_KEY&lt;/code&gt; 4个 repo secrets, 一次只能添加一个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Name: U_NAME, U_EMAIL, WORK_TOKEN, OPENAI_API_KEY&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Value: 分别为 U_NAME 上面所说的你的用户名, U_EMAIL 是上面所说的你的邮箱, WORK_TOKEN 是你刚刚复制的 token&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 “Add secret“&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.4 给需要的权限&lt;/h3&gt;
&lt;p&gt;开启 GitHub Actions 访问 Pages 的权限&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/pages.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;点击 “Settings” &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在左侧 “Code and automation” 下找到 “Pages” 点击进入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 Source 设置为 deploy from main branch /docs folder. 即从 main 分支的 docs 文件夹部署到 Pages 上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2 设置需要合并, 过滤, 总结的 RSS 源&lt;/h2&gt;
&lt;p&gt;进入项目, 点击上方菜单栏的 &#34;Code&#34;, 点击进入 &#34;config.ini&#34; 文件, 点击右上角的铅笔图标, 编辑代码, 设置你需要的订阅源, 前两行的内容不要动。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[cfg]
base = &#34;docs/&#34;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后在接下来的三行更改&lt;strong&gt;目标语言, 关键词数量, 和总结长度&lt;/strong&gt;。之后的代码是 feed-specific 的配置, 格式如下, 首先是3个必填项目:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[source001]&lt;/code&gt;: 订阅序号, 从001开始增长, 注意请确保编号不要重复, 不然代码会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name = &#34;brett-terpstra&#34;&lt;/code&gt;: 生成订阅源的名称, 只允许包含英文字母(a-z A-Z)、数字(0-9)、(&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;_&lt;/code&gt;,&lt;code&gt;.&lt;/code&gt;,&lt;code&gt;~&lt;/code&gt;) 4个特殊字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;url = &#34;https://brett.trpstra.net/brettterpstra&#34;&lt;/code&gt;: 原始RSS订阅链接, 可以包含多条, 用逗号分隔&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;max_items = &#34;10&#34;&lt;/code&gt;: 两次刷新间隔之间需要总结的文章数量。比如你设置为10, 那么每次刷新时, 会把最新的10条文章进行总结。如果设置为0或者不设置, 则不会总结任何文章, 返回原始条目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来是关于过滤的可选配置: &lt;strong&gt;注意三个配置必须要同时设置或者同时不设置, 不能只设置其中一个或者两个, 否则会报错。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filter_apply = &#34;title&#34;&lt;/code&gt;: 过滤条件需要应用在 &#34;title&#34;（标题）, &#34;article&#34; （正文内容）or &#34;link&#34; （链接）&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;filter_type = &#34;exclude&#34;&lt;/code&gt;: 过滤类型: ”include“（包含）,  “exclude“（不包含）, or ”regex match“（正则匹配）or ”regex not match“（正则不匹配）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;filter_rule = &#34;TextExpander&#34;&lt;/code&gt;: 过滤内容, 字符串或者正则表达式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;点击最下边的 “Commit changes” 提交修改。&lt;/p&gt;
&lt;h2&gt;3.1 修改 main.py 中的仓库名称&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(如果你在 1.1 中使用了默认仓库名称，或者你不想要修改 prompt, 可以跳过这一步)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进入 “main.py&#34; 文件, 点击笔形图标, 编辑代码, 进入第 290 行,  修改 &#34;https://{U_NAME}.github.io/RSS-GPT&#34; 中的 RSS-GPT 为你的仓库名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（可选）根据你的需求, 可以在 113 - 129 行修改 prompt, 让 GPT 生成更符合你需求的总结。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击最下边的 “Commit changes” 提交修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4 开启并测试 GitHub Actions&lt;/h2&gt;
&lt;p&gt;进入项目, 点击上方菜单栏的 &#34;Actions&#34;, 点击 “cron_job&#34;, 选择 “Run workflow&#34;&lt;/p&gt;
&lt;p&gt;等待运行成功会显示绿色的勾, 运行失败会显示红色的叉。如果出现红叉, 一般都是你修改 ini 文件时, 什么地方写错了, 或者权限、Secrets 设置错误。请仔细检查。&lt;/p&gt;
&lt;p&gt;如果前边没出现错误 (主要是运动 Actions 没出现红叉), 那么你可以在项目的介绍页看到你的订阅源。&lt;/p&gt;
&lt;p&gt;每条项目的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 左侧的是原始订阅链接, 右侧是转换后的链接。请确保你已经在第3步中设置了你自己的 GitHub Pages 地址。在任何 RSS 阅读器中订阅右侧的链接即可。&lt;/p&gt;
&lt;h2&gt;一些额外的说明&lt;/h2&gt;
&lt;h3&gt;关于 feed 刷新频率&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;默认设置是每2小时运行一次脚本, 如果有不同需要，请修改 &lt;code&gt;.github/workflows/cron_job.yml&lt;/code&gt; 文件第7行, 比如：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;- cron: &#39;0 */2 * * *&#39; # 每2小时运行一次
   - cron: &#39;0 */1 * * *&#39; # 每1小时运行一次
   - cron: &#39;0 0 * * *&#39; # 每天0点运行一次
   - cron: &#39;*/30 * * * *&#39; # 每30分钟运行一次&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更加具体的参数可以查看 &lt;a href=&#34;https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule&#34;&gt;crontab&lt;/a&gt; 的用法 或者&lt;a href=&#34;https://crontab.guru/&#34;&gt;crontab.guru&lt;/a&gt; 的文档。&lt;/p&gt;
&lt;h3&gt;如果你不想要 AI 总结的功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;你仍然可以使用本脚本来过滤和合并多个订阅源，只需要在 1.3 不设置 OpenAI API Key，或者在 &lt;code&gt;config.ini&lt;/code&gt; 中不设置 &lt;code&gt;max_items&lt;/code&gt; 或者设置为 0 即可，这个脚本默认在 AI 调用失败时也能返回文章原始条目。 &lt;/li&gt;
&lt;li&gt;如果你想要 AI 总结功能并且正确设置了 &lt;code&gt;config.ini&lt;/code&gt;，但是仍然返回原始条目或者久久不更新， 请检查&lt;code&gt;docs/&lt;/code&gt; 文件夹内的 &lt;code&gt;feed_name.log&lt;/code&gt; 文件中查看 OpenAI API 或者 feedparser 的错误信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;关于 OpenAI 总结的内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我设定的 prompt 是让 AI 帮助提取 关键词 + 总结 并且让 AI 自动排版, 有些时候 AI 排版的效果并不是很好, 你也可以根据自己需要修改 &lt;code&gt;main.py&lt;/code&gt; 第 113 - 129 行的 prompt。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AI 总结的内容基于 feed 中每条文章的描述，如果 RSS 本身提供全文，则会全文总结；如果 RSS 仅提供文章摘要，则总结基于摘要，目前脚本没有提供抓取原文全文的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;关于 OpenAI API 的用量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;关于 OpenAI API 的用量，为了尽可能保证费用尽可能低，本项目采取了以下默认措施：&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有非文本内容（图片，框架，HTML 标签等）在让 GPT 总结之前都会被移除，以节约 token 用量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据文本长度选取不同的模型，而如果文本长度超过了 16k，&lt;code&gt;gpt-4-1106-preview&lt;/code&gt; 模型会被使用，否则默认使用 &lt;code&gt;GPT-3.5 Turbo&lt;/code&gt;。如果你想要使用不同的模型，可以在 &lt;code&gt;main.py&lt;/code&gt; 文件修改第 227 - 243 行中传入 &lt;code&gt;gpt_summary&lt;/code&gt; 函数的参数 &lt;code&gt;model=&#34;your_model&#34;&lt;/code&gt; 。请参考 &lt;a href=&#34;https://openai.com/pricing/&#34;&gt;OpenAI API Pricing&lt;/a&gt; 了解不同 OpenAI 模型的不同价格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;脚本会读取 docs/ 文件夹中已存在的 xml 文件，已经存在的文章不会再次总结，所以不会重复消耗用量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;关于仓库更新&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我把仓库中手动修改和 workflow 自动提交修改放到了不同的分支，所以你可以直接在 &lt;code&gt;dev&lt;/code&gt; 分支中看到我最后一次手动修改的时间和内容，来决定是否拉取最新的修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 OpenAI 之后发布了更多的模型，我会酌情选择最合适的默认模型，修改代码。如果你有更合理的使用 AI 的方案或者使用过程中有问题，或者发现本教程有错误，欢迎 &lt;a href=&#34;mailto:yinan.email@gmail.com&#34;&gt;email&lt;/a&gt; 交流。最后，如果你觉得本教程或本项目对你有帮助，欢迎 star &lt;a href=&#34;https://github.com/yinan-c/RSS-GPT&#34;&gt;本项目&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  
  <entry>
    <title>Separating tasks and non-actionable items</title>
    <link ref="alternate" href="https://yinan.me/separating-tasks-and-lists.html" />
    <id>separating-tasks-and-lists</id>
    <published>2023-09-20 17:20:56+01:00</published>
    <updated>2023-11-04 15:41:59+00:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;h2&gt;The thought&lt;/h2&gt;
&lt;p&gt;I read an discusion about devonthink on MPU forum, &lt;a href=&#34;https://talk.macpowerusers.com/t/yet-another-devonthink-topic/15628&#34;&gt;Yet another DevonThink topic - Software - MPU Talk&lt;/a&gt; and came across a interesting and much enlighting comment by &lt;a href=&#34;https://talk.macpowerusers.com/t/yet-another-devonthink-topic/15628/18&#34;&gt;@ryanjamuraphy&lt;/a&gt;, when he was talking about his usage of &lt;a href=&#34;https://www.devontechnologies.com&#34;&gt;Devonthink&lt;/a&gt; as a Notes and annotations database:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Incidentally, one lesson I learned from my recent Things adventure is that I put a lot of non-actionable items in OmniFocus. As a result, probably half of the items in there were just noise. Most of these items were just thinking on potential projects or links to things I wanted to investigate. Instead of putting them in OmniFocus, I aim now to keep my task manager clean and lean. Instead, I’ll rely on PARA/CODE and put those non-actionable items in DEVONthink as a notes database. I plan on working in DT3 on my desktop a lot more to make this happen.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I personally use &lt;a href=&#34;https://culturedcode.com/things/&#34;&gt;Things 3&lt;/a&gt; as my task manager and recently started using &lt;a href=&#34;https://www.devontechnologies.com/apps/devonthink&#34;&gt;Devonthink&lt;/a&gt; as my notes/documents/bookmarks database. This idea of separting tasks and non-actionable items suddenly hit me and I decided to write something about it:&lt;/p&gt;
&lt;h2&gt;My old workflow&lt;/h2&gt;
&lt;p&gt;This is my Things 3 window usually looks like:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://yinan.me/pics/Things.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;As you can see from the sidebar, there are 40 items in &#39;Inbox&#39;, 7 in &#39;Today&#39;, Besides these 2 there are also &#39;Upcoming&#39;, &#39;Anytime&#39;, &#39;Someday&#39; -- These time-based lists are where you assign your tasks to based on urgency and importance.&lt;/p&gt;
&lt;p&gt;In the meanwhile, there are tags, projects, and areas where you use to catorgorize your tasks.&lt;/p&gt;
&lt;p&gt;Inbox is something we all learned about when using emails. In the email world, it is where you receive all your emails, and you process them by replying, forwarding, or deleting them. I use inbox in Things 3 as a place to capture everything from everywhere:&lt;/p&gt;
&lt;p&gt;A typical workflow of mine using Things 3 is that I will capture &lt;strong&gt;everything&lt;/strong&gt; to inbox, thoughts, tasks, articles I found online or from RSS feeds. Then I will process the inbox on a regular base, assigning tasks to the time-based lists, tagging them and carogorizing to different projects, and areas.&lt;/p&gt;
&lt;h2&gt;The problem&lt;/h2&gt;
&lt;p&gt;This sounds awesome, which helps me to keep my mind clear and focused on what I am doing at the moment. In the meanwhile, I don&#39;t have to worry about losing anything that comes up while I am in the middle of something.&lt;/p&gt;
&lt;p&gt;But there is a problem underlying this workflow: &lt;strong&gt;The inbox is quickly filled up with non-actionable items, making it hard to process the inbox and find the important things to do.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;More often than not, you will find yourself doing a lot of easy yet non-important tasks, like replying emails, or reading articles, instead of doing the important difficult tasks that you should really be doing at the moment.&lt;/p&gt;
&lt;h2&gt;The 2 lists&lt;/h2&gt;
&lt;p&gt;Actionable tasks is generally sparse yet important, which should either be done or sorted out and/or asigned as soon as possible, in case they are forgotten.&lt;/p&gt;
&lt;p&gt;Articles in readlist is non-actionable, something you can postponed even abandoned because of time-sensitivity.&lt;/p&gt;
&lt;p&gt;There are always things happening, and you will always find new things to read. It is genneraylly impossible and not a good idea to devote your limited time to read infinite amount of information and articles.&lt;/p&gt;
&lt;p&gt;If you are like me, using RSS to fetch information online and capture the interesting ones to things inbox without tagging or sorting them at the first place. You will find that your readlist is growing very fast. And more often than not, you will find your tasks buried in the inbox under a pile of readlist items.&lt;/p&gt;
&lt;h2&gt;The solution&lt;/h2&gt;
&lt;p&gt;The solution is simple: &lt;strong&gt;separate the tasks and non-actionable items&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now I put all my readlist items to Devonthink, using smart rules to automatically tag them based on the source, convert them to pdf/webarchive, and put them in the &#39;readlist&#39; database so that I can read them when I have time.&lt;/p&gt;
&lt;p&gt;This smart rule function is similar to mail rules in email clients, where you can automatically sort your emails based on the sender, subject, etc. All these can be done automatically thanks to the powerful &lt;a href=&#34;https://www.devontechnologies.com/blog/20201110-organize-with-smart-rules&#34;&gt;smart rules&lt;/a&gt; in Devonthink.&lt;/p&gt;
&lt;p&gt;I can use Things 3 as a pure task manager which I can start working on right away, and I use Devonthink as a readlist/documents database which I can search for information when I need them.&lt;/p&gt;
&lt;h2&gt;Some final words&lt;/h2&gt;
&lt;p&gt;Things 3 alone works great as a list/task manager, which can serve for multiple purposes. Despite the inability to store files, it can still be used as a proper readlist, a bookmark manager, a notes database, etc.&lt;/p&gt;
&lt;p&gt;Without that being said, I found it much easier to keep my mind clear and focused by separating tasks and non-actionable items, and leave certain things to Devonthink.&lt;/p&gt;
&lt;p&gt;But you can still manage your lists, get away with inbox zero, and keep your task management clean in Things 3 alone.&lt;/p&gt;
&lt;p&gt;For example, to achieve inbox zero, you can also tag/move/schedule your captures at the first place before sending to Inbox. This is basically processing inbox on the go before it gets too big.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The author is not affiliated with any of these companies or products mentioned above.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;References and further reading&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://talk.macpowerusers.com/t/yet-another-devonthink-topic/15628&#34;&gt;Yet another DevonThink topic - Software - MPU Talk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://fortelabs.co/blog/para/&#34;&gt;The PARA Method: A Universal System for Organizing Digital Information&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.devontechnologies.com/blog/20201110-organize-with-smart-rules&#34;&gt;How to Organize with Smart Rules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  
  <entry>
    <title>折腾</title>
    <link ref="alternate" href="https://yinan.me/zheteng.html" />
    <id>zheteng</id>
    <published>2023-11-02 17:17:47+00:00</published>
    <updated>2023-11-02 18:20:04+00:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;p&gt;最近又开始折腾博客了，我用的是 &lt;a href=&#34;https://github.com/yinan-c/pyboke&#34;&gt;Pyboke&lt;/a&gt;，一个通过 Python 实现的简约的博客生成器。&lt;/p&gt;
&lt;p&gt;简约，换句话说就是能够实现的功能比较简单。所以会有很多想法, 有些接入第三方 API 修改模板即可实现，有些则可能需要修改 Pyboke 源代码。虽然这些想法也不一定都会实现，但还是记录下来，之后有时间再慢慢折腾。&lt;/p&gt;
&lt;h2&gt;ChatGPT 总结&lt;/h2&gt;
&lt;p&gt;首先就是 AI 总结，ChatGPT 已经帮我总结了不少 &lt;a href=&#34;https://yinan.me/RSS-GPT/index.html&#34;&gt;RSS 订阅源&lt;/a&gt;。在决定深入阅读前，可以先借助 AI 总结的内容判断是否感兴趣，效果很不错。&lt;/p&gt;
&lt;p&gt;尝到甜头后我就想能不能也用在自己的博客文章中，方便游客快速了解文章内容。首先的想法是加一个 metadata 条目 &#39;summary&#39;，然后在提交文章时自动调用 ChatGPT 总结，把结果填入 summary 中，因为之前主页上的预览也是这样做的，再加上我之前也写过 &lt;a href=&#34;https://github.com/yinan-c/RSS-GPT&#34;&gt;RSS-GPT&lt;/a&gt;，所以花了一些功夫就写出大概功能了。但是目前还有几个问题没解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是否所有文章都需要总结？是否要在 metadata 文件中加一个条件判断？比如有些文章，about，contact 等，可以加一个 &lt;code&gt;ignored = True&lt;/code&gt; 标签。&lt;/li&gt;
&lt;li&gt;文章的 metadata 是在运行 &lt;code&gt;pyboke&lt;/code&gt; 之后才生成的，如果要加条件判断，那么就需要在生成 metadata之后，再运行脚本进行 ChatGPT 总结。&lt;/li&gt;
&lt;li&gt;那么，是否应该引入 YAML 格式的 front matter，来代替现在 toml 格式分开存储的 metadata？这样就可以在文章中直接设定是否需要总结，而不需要在生成 metadata 之后再手动修改。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这些问题还没有定论之间，我还没有想要把自动总结加入 Pyboke 的源代码。目前以我可怜的博文数量以及更新频率来看，手动让 GPT-4 总结，然后添加到 metadata 后通过 Jinja 模板自动渲染，应该就够了。 &lt;/p&gt;
&lt;p&gt;我还在考虑是否需要将 AI summary 附加在 RSS 上，那么在这种情况下，需要在发布文章之前就附上总结，并且修改 &lt;code&gt;atom.xml&lt;/code&gt; 的模板使其包含总结信息。这样自动化总结或许是更好的方案。&lt;/p&gt;
&lt;p&gt;如果你想要折腾自动化的方案，并且用的是 Hugo，可以参考大大的小蜗牛的&lt;a href=&#34;https://eallion.com/ai-summary/&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;评论和点赞&lt;/h2&gt;
&lt;p&gt;之前看过水八口的一篇帖子&lt;a href=&#34;https://shuiba.co/third-party-comments-2023&#34;&gt;第三方评论之2023年版&lt;/a&gt;详细对比了不同方案的优缺点。&lt;/p&gt;
&lt;p&gt;最终决定用了&lt;a href=&#34;https://giscus.app/&#34;&gt;giscus&lt;/a&gt;，利用的是 &lt;a href=&#34;https://github.com/yinan-c/pages-comment&#34;&gt;GitHub Repository&lt;/a&gt; 的 discussions 功能，所以既可以在 Repo 里评论，也可在博客内评论。好在设置非常简单，在 template html 加上一段 js 脚本即可。除了评论点赞必须要登录 GitHub 账号外，目前没有什么太大问题。&lt;/p&gt;
&lt;p&gt;这两天又在逛博客，发现了一些很有趣的方案，&lt;a href=&#34;https://yuxiyuqi.com&#34;&gt;Yuxi&amp;amp;Yuqi&lt;/a&gt;的评论是用的&lt;a href=&#34;https://twikoo.js.org/en/&#34;&gt;twikoo&lt;/a&gt;，&lt;a href=&#34;https://koobai.com/&#34;&gt;koobai&lt;/a&gt; 用了 &lt;a href=&#34;https://artalk.js.org/en/&#34;&gt;Artalk&lt;/a&gt;，&lt;a href=&#34;https://zishu.me/&#34;&gt;子舒的博客&lt;/a&gt;用了 &lt;a href=&#34;https://github.com/emaction/emaction.frontend&#34;&gt;emaction&lt;/a&gt; 来实现 emoji reaction，点赞无需登录，也可以自己部署&lt;a href=&#34;https://github.com/emaction/emaction.backend&#34;&gt;后端&lt;/a&gt;。后续可能会考接入我的博客。&lt;/p&gt;
&lt;h2&gt;全文 RSS&lt;/h2&gt;
&lt;p&gt;这是之前一段时间 (2023-09) 就已经实现的功能。原项目的 RSS 带了 Markdown 的格式符以及截取到前 150 个字符。我给 Markdown 转成了 HTML，并取消了字数限制，这样就可以直接在 RSS 阅读器里看到全文了。&lt;/p&gt;
&lt;h2&gt;Memos as in-line &#34;Tweet&#34;&lt;/h2&gt;
&lt;p&gt;我想要把生活中简短的点滴放在博客，而不是仅仅写长 posts，推特本来是一个理想的平台，但是因为 Twitter API 以及 RSS 的封闭，除了 &lt;a href=&#34;https://publish.twitter.com/&#34;&gt;embed Twiiter&lt;/a&gt;，我好像没有特别好的办法把上面的内容搬运过来。&lt;a href=&#34;https://koobai.com/memos&#34;&gt;Koobai&lt;/a&gt;的“唠叨”使用的是 &lt;a href=&#34;https://github.com/usememos/memos&#34;&gt;Memos&lt;/a&gt; 方案，而&lt;a href=&#34;https://yuxiyuqi.com/timeline/&#34;&gt;Yuxi&amp;amp;Yuqi&lt;/a&gt; 则使用了时间线的方式, 目前我还没搞懂是用的啥方案还是自己搭的。&lt;/p&gt;
&lt;p&gt;关于这个功能，我目前并不急着实现，就算之后要选择第三方实现，数据的 privacy, self-hosted 对我来说，应该是首要考虑因素。&lt;/p&gt;
&lt;h2&gt;展示个性化订阅源&lt;/h2&gt;
&lt;p&gt;使用 &lt;a href=&#34;https://github.com/avadhesh18/rssTea&#34;&gt;rssTea&lt;/a&gt; 展示播客订阅源，或个性化的订阅源，比如即刻，v2ex动态等。&lt;/p&gt;
&lt;h2&gt;暂时搁置的功能&lt;/h2&gt;
&lt;p&gt;搜索和标签, 目录&lt;/p&gt;
&lt;p&gt;目前来看，Pyboke 以 metadata 以 toml 格式保存以及与文章分开存储的方案，相比较于 YAML front matter，各有利弊，前者保留了 Markdown 的文本格式，后者则可以直接在文章中修改 metadata。目前新添加的功能例如 首页预览，文章内总结，确实需要在渲染生成 metadata 文件之后，然后手动进入文件修改。但是目前以我更新博客的频率来看，还是可以接受的。如若以后有了更多需要手动添加的 metadata，例如标签，那么我或许会考虑引入 YAML front matter。最后一句话赶紧掐断我写下更多的折腾的想法吧，Hey, if it ain&#39;t broke, don&#39;t fix it.&lt;/p&gt;
&lt;h2&gt;Further Reading&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://eallion.com/ai-summary/&#34;&gt;博客 AI 摘要及优化 - 大大的小蜗牛&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://shuiba.co/third-party-comments-2023&#34;&gt;第三方评论之2023年版 - 水八口&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  
  <entry>
    <title>AI 总结 RSS Feeds</title>
    <link ref="alternate" href="https://yinan.me/rss-gpt.html" />
    <id>rss-gpt</id>
    <published>2023-09-07 14:21:35+01:00</published>
    <updated>2023-09-29 19:19:18+01:00</updated>
    <author><name>Yinan</name></author>
    <content type="html">&lt;h2&gt;项目地址与配置教程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yinan-c/RSS-GPT&#34;&gt;yinan-c/RSS-GPT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yinan-c.github.io/rss-gpt-manual-zh.html&#34;&gt;RSS-GPT 配置教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;信息爆炸的焦虑&lt;/h2&gt;
&lt;p&gt;RSS 是我一直在用并且非常喜欢的信息获取方式，你可以把你喜欢的内容创造者或者大多网页上更新的内容聚合在一个地方集中阅读。但不加筛选，富含噪音的 RSS 在订阅中堆积也很让人疲惫不堪。每天几百几千条未读产生，如果强迫症和焦虑症患者强求 RSS inbox-zero 的话，久而久之会浪费很多的时间执着于清空未读上面，实属折磨。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Heavy Inbox&#34; src=&#34;https://yinan.me/pics/Inbox.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;并且即使你全部清空了阅读，多半情况下 inbox 空空，脑袋也空空，因为这时候你已经没有精力去消化，而是像短视频一样消费 RSS 内容，你只是得到了匆匆而过的信息，没有内化沉淀成知识，而代价却是时间，注意力和精力。&lt;/p&gt;
&lt;h2&gt;RSS 过滤&lt;/h2&gt;
&lt;p&gt;在这种情况下，摆脱 &lt;a href=&#34;https://en.wikipedia.org/wiki/Fear_of_missing_out&#34;&gt;FOMO - Fear of missing out&lt;/a&gt; 的心态是很重要的。一个非常有效的方法就是，对 RSS 进行关键词过滤，只保留自己真正感兴趣愿意花时间阅读的内容。&lt;/p&gt;
&lt;p&gt;我目前知道有两个小工具可以做到 RSS 过滤，&lt;a href=&#34;https://siftrss.com&#34;&gt;SiftRSS&lt;/a&gt;, 另外还有一个 &lt;a href=&#34;https://feedless.org&#34;&gt;Feedless&lt;/a&gt;。我只用过前一个，体验很不错，可以根据 description，title 等建立不同的 filter。 可以看到很多人都在用，作者也一直为爱发电。&lt;/p&gt;
&lt;h2&gt;RSS 翻译&lt;/h2&gt;
&lt;p&gt;前段时间在看到了一个这样的项目 &lt;a href=&#34;https://github.com/tjsky/RSS-Translation/tree/main&#34;&gt;RSS-Translation&lt;/a&gt;, 作者写了非常详细的教程教你如何用 GitHub Actions，来自托管翻译 RSS 订阅源。原项目应该是&lt;a href=&#34;https://github.com/talengu/rss-translate&#34;&gt;这个&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;RSS 摘要&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;RSS-GPT&#34; src=&#34;https://yinan.me/pics/RSS-GPT.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;其实对我来说，相比较翻译，对 RSS 全文的中文总结更有价值，这样我可以快速了解到这篇文章的主要内容，来决定是否进一步精读。所以我最近写了这样一个工具，可以全文总结 RSS 订阅源，提取关键词，生成摘要附在原文之前，方便阅读。除了 AI 摘要，另外还有合并 RSS 订阅源，过滤订阅源的一些功能，可以详见 &lt;a href=&#34;https://github.com/yinan-c/RSS-GPT&#34;&gt;RSS-GPT&lt;/a&gt;。如果想要自己配置自己喜欢的订阅源，可以 fork 我的项目，部署十分简单，只需要更改 config.ini，给 Repo GitHub Pages 权限，以及设置 WORK_TOKEN（Github Token to access GitHub repo and enable workflow）, U_NAME (Git commit user name), U_EMAIL (Git commmit user email), OPENAI_API_KEY 这四个 repo_secrets 即可。&lt;/p&gt;
&lt;p&gt;我写了一篇详细的&lt;a href=&#34;https://yinan-c.github.io/rss-gpt-manual-zh.html&#34;&gt;指南&lt;/a&gt;，希望能帮助到大家。&lt;/p&gt;
&lt;p&gt;这里也汇集几条我公开的 &lt;a href=&#34;https://yinan.me/RSS-GPT/&#34;&gt;RSS 源&lt;/a&gt;，欢迎大家订阅。&lt;/p&gt;</content>
  </entry>
  

</feed>